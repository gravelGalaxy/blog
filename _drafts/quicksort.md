---
title: 快速排序
tags: Algorithm
---
# 快速排序介绍
快速排序基于分治思想，将一个大问题分解为若干个小问题，之后逐个进行求解。在每一次递归中，首先选择一个基准值，然后将数组中小于基准值的数放在左边，把大于基准值的数放到右边。如果左右边界相等(`l == r`)，则说明需要处理的只有一个元素，直接返回即可(递归的基准情况)。

# 快速排序的基本步骤
1. 选择一个基准值。
2. 使用双指针，i指向数组的最左边还要左一位(`i = l - 1`)，j指向数组的最右边还要右一位(`j = r + 1`)。
3. 执行一个循环，其条件为左指针小于右指针`i < j`，即当`i >= j`时则本次将数组中按基准值进行处理的操作执行完毕。在循环中，将左指针移动到第一个遇到的比基准值大的数，将右指针移动到比基准值小的数，如果有`i < j`，则交换这两个数，否则说明循环该结束了。
4. 此时已经将小于基准值的集合放在了靠左部分，将大于基准值的集合放到了靠右部分，而等于基准值的部分放在左边还是右边无所谓。靠左部分和靠右部分是分治出来的两个子问题，接下来要分别对靠左部分和靠右部分执行快速排序算法。

# 快速排序模板
```C++
void quick_sort(int q[], int l, int r) {
    if (l >= r) return ;
    int x = q[l], i = l - 1, j = r + 1;
    while (i < j) {
        do i++; while (q[i] < x);
        do j--; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
```
**要点**
1. `i`和`j`在退出while循环时一定指到同一个位置。
2. 基准值的选取与后面对子问题进行的快速排序参数的关系。
- 当基准值选取给定范围第一个元素的时候，后面进行快速排序时右边界应该为`j`而不能为`i`，因为当要排序的数组只有两个数且指针j不移动，指针i移动到j时，`quick_sort(q, l, j);`就相当于`quick_sort(q, l, r)`，会发现子问题和父问题是同样的问题，这就发生了无限递归。

        
