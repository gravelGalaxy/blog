---
title: 在基类中使用保护区域
tags: OOD
---

    本节是在阅读《OOD启思录》时的记录。
在学习完C++课程之后，我从来没有想清楚过什么时候应该使用`protected`，感觉使用`public`和`private`就可以完成所有事，在`public`里放公共方法，在`private`中放私有成员变量，这样就能完成需求呀，为什么会有`protected`这种权限呢？

# `proteced`的使用场景
如果有一个水果类`Fruit`，它有`weight`和`color`两个数据成员，还有一个输出操作：“你好，我是一个3磅重的红色水果。”如果在这里有一个继承自`Fruit`类的苹果类`Apple`，它是否需要重写输出操作，使输出变为“你好，我是一个苹果，我重3磅”？如果想要重写输出，我们发现在此时`Apple`类需要使用`Fruit`类中的数据成员`weight`，如果把`weight`设置为私有成员，`Fruit`类就不能使用这个数据成员，也就达不到我们的目的。此时我们应该把`weight`设置为保护成员还是增加一个函数来获取该变量呢？
# 经验原则：基类中的数据都应当是私有的
如果将`weight`设置为`protected`，继承类就能够访问这一数据成员。但设计应有长远的考虑：在未来`weight`是否会发生变化？`weight`的类型一定是一个`double`吗？`weight`会不会变成一个结构体？如果发生变化，会有多少派生类受影响？

如果我们20年后会在30个不同的星球上吃苹果，`weight`可能会变成一个包含`质量`和`加速度`的结构体。此时如果将`weight`设置为`protected`，暴露`weight`的实现，那么在需要将`weight`改为结构体时，就需要修改**所有**派生类中与`weight`有关的部分，代价是很大的。

而如果我们使用一个方法`get_weight`获取苹果的重量，那么我们在修改`weight`成为结构体之后，只需要修改`get_weight`的实现，就可以重新获取正确的重量。此时`Apple`类的方法只依赖于`Fruit`的接口，而不依赖于`Fruit`的实现。

实际上，应将`get_weight`设置为`protected`，这里才是`protected`应该作用的地方。

为了避免`全能类`，应该将`get_weight`设置为`protected`，而不是`public`。不应该在类中对公共接口定义大量`get`、`set`访问方法，这往往意味着有其他更大类从该类中获取数据，并在更大的类中进行集中控制。我在`C#`和`Java`中看到有很多类有这样的`get`、`set`方法，对这一块问题还不太清楚。

