---
title: 字符串
tags: C++
---
# 字符串的特点
字符串的特点可以归纳为：结构简单，规模庞大，元素重复率高。
- 结构简单：指`字符表`本身规模不大。
- 规模庞大：指以字符串形式表示的文本数据是海量的。
- 元素重复率高：是结构简单，规模庞大的结果。
# 字符串ADT
字符串可能需要完成以下操作：
```C++
length()        //查询字符串长度
charAt(i)       //返回第i个字符
substr(i, k)    //返回从第i个字符开始长度为k的子串。
prefix(k)       //返回字符串长度为k的前缀
suffix(k)       //返回字符串长度为k的后缀
equal(T)        //判断T与当前字符串是否相等
concat(T)       //将T连接在当前串之后
indexOf(P)      //若P是当前字符串中的一个子串，返回他的起始位置；否则返回-1
```
# 字符串匹配
字符串匹配问题可以分为四类：模式检测问题、模式定位问题、模式计数问题、模式枚举问题。
1. 模式检测问题：只关心是否存在。
2. 模式定位问题：需要确定具体位置。
3. 模式计数问题：需要统计多处匹配的位置总数。
4. 模式枚举问题：需要指出所有匹配的位置。

这里首先给出字符串匹配的暴力算法。
```C++
int match (char *T, char *P) {
    size_t n = strlen(T), i = 0; 
    size_t m = strlen(P), j = 0;
    while (i < n && j < m) {
        if (T[i] == P[j]) 
            i++, j++;
        else {
            i -= j - 1;
            j = 0;
        }
    }
    return i - j;       //i - (j + 1) + 1
}
```
假设文本串长度为n，模式串长度为m，则该算法的最坏时间复杂度为`m * (n - m + 1)`，即最多需要迭代`n - m + 1`轮，且每轮最多`m`次比对。渐进时间复杂度应为`O(n * M)`。而在最好的情况下，每轮最多`1`次比对，运行时间将为`O(n)`，在字符表较大时出现（接近）最好情况的概率并不低。






